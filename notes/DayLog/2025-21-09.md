The plan for today is [[CHECKLIST#Block 2 Arrays - Subarray Sums & Kadane's Variants (Approx. 3h 55m)|Block 2]]
- **Study Questions:**
  - [x] Best Time to Buy and Sell Stock (Easy)
  - [x] Maximum Subarray (Medium)
  - [x] Minimum Size Subarray Sum (Medium)
- **Practice Questions:**
  - [x] Majority Element (Easy)
  - [ ] Subarray Sum Equals K (Medium)
  - [ ] Shortest Unsorted Continuous Subarray (Medium)
  - [ ] Kth Largest Element in an Array (Medium)
## Study Questions
### Buy and Sell Stock
So i kinda thought of the two-pointer solution myself. I didn't implement it of course but I came up with it within 5 minutes. However then I discovered there was another way of solving it, applying something called "Kadane's Algorithm". This is apparently used to calculate the max subarray sum originally, but it can be tweaked to be applied here as well. The more intuitive one to me of course is the two pointers. But this one makes sense as well, here is Kadane's theory:
> [!info]-
> Kadane’s algorithm finds the largest sum of any contiguous subarray in a list in one pass.
> Simple idea:
> - Walk through the numbers, keeping a running sum of the best subarray that ends at the current position.
> - If the running sum ever drops below zero, reset it to the current number (start fresh).
> - Keep track of the best sum you’ve seen so far.

I've included both solutions in my python file just in case.
**Key intuitions:**
- If having to accumulate something over an array, consider if Kadane could be applied.
### Maximum Subarray
This puts in practice "Kadane's Algorithm" in it's most traditional way. I see it as a way of dropping "dead weight" when it's not contributing anything. This is basically, if a subarray has a total sum of 0 or less, we drop it, since it won't contribute anything moving forward.
I also did a custom nice thingy where I modified it to return the indexes of the subarrays.
**Key intuition:**
- Sliding window would not work here. Why? because it's not sliding! if the sum becomes <= 0 we basically ditch the window and start over!
### Minimum Size Subarray Sum
I tried to apply Kadane at first since it's pretty similar to the previous one, but it didn't work out. It turns out that whenever we have other constraints and concerns that aren't just minimizing or maximizing a sum, then we're outta luck. From GPT-5:
> Where Kadane fits:
> - Max subarray sum (classic).
> - Max profit from one stock trade via day-to-day differences.
> - Variants that still boil down to “best contiguous sum” on a transformed array (e.g., circular arrays with tweaks, 2D via compression).
> - Min subarray sum by negating numbers and applying Kadane.

> Where it doesn’t fit directly:
> - Problems with constraints beyond sum (e.g., shortest/longest subarray meeting a threshold, at most K distinct chars, exact length k).
> - When elements can be negative and you need a constraint like “sum ≥ K” with minimal length—requires prefix sums + binary search or a deque.
> - Non-contiguous selections (that’s knapsack/DP territory).
> - Multi-criteria objectives (e.g., maximize average, ratio, or product) unless you can reduce to a sum with a transformation.
> 
> Rule of thumb:
> - If your goal is “best contiguous sum” (possibly after a simple transform), use Kadane.
> - If you’re enforcing constraints or optimizing length/indices under a threshold, reach for sliding window, prefix sums, or dynamic programming.
## Practice Problems
### Majority Element
This one was different! At first it was easy, just use hashmap and dassit. But then the challenge was to do it $O(1)$ in memory. To do this, you take advantage of the fact that its **guaranteed** that there it's going to be a "majority element" that is going to be present n/2 (rounded up) times.
So you can keep a single count with a "candidate". Whenever you see that candidate, you increase the count. Whenever the count reaches 0, you switch
candidates. Eventually, in the end you will be left with the right candidate. This is because no matter how many times you decrease the count, there is still a majority of elements.
This actually has a name, "Boyer-Moore" algorithm.
**Key Intuitions**
- Consider this when there is two clear "adversaries". In this case it was the majority element vs the rest of the elements. Aura.
### Subarray Sum Equals K (Medium)
Oh brother. This has been the hardest one by far. It I guess has similar intuitions to previous (not really). It needs something called "prefix sum". Which is basically a technique in which you precalculate the cumulative sum at all indexes in an array. In this case instead of precalculating you do it on the fly, and count the amount of "prefixes" you have for each sum. Each prefix ultimately represents a way that we can remove from the current subarray (which starts from 0), so for each different prefix we have a different subarray.
**Key Intuitions:**
- I still don't completely know tbh
- Looks like, whenever you need some subarray sum or similar with another constraint (in this case finding k) and you can't use sliding window due to there being negatives.
