The plan for today is [[CHECKLIST#Block 2 Arrays - Subarray Sums & Kadane's Variants (Approx. 3h 55m)|Block 2]]
- **Study Questions:**
  - [x] Best Time to Buy and Sell Stock (Easy)
  - [x] Maximum Subarray (Medium)
  - [x] Minimum Size Subarray Sum (Medium)
- **Practice Questions:**
  - [ ] Majority Element (Easy)
  - [ ] Subarray Sum Equals K (Medium)
  - [ ] Shortest Unsorted Continuous Subarray (Medium)
  - [ ] Kth Largest Element in an Array (Medium)
## Study Questions
### Buy and Sell Stock
So i kinda thought of the two-pointer solution myself. I didn't implement it of course but I came up with it within 5 minutes. However then I discovered there was another way of solving it, applying something called "Kadane's Algorithm". This is apparently used to calculate the max subarray sum originally, but it can be tweaked to be applied here as well. The more intuitive one to me of course is the two pointers. But this one makes sense as well, here is Kadane's theory:
> [!info]-
> Kadane’s algorithm finds the largest sum of any contiguous subarray in a list in one pass.
> Simple idea:
> - Walk through the numbers, keeping a running sum of the best subarray that ends at the current position.
> - If the running sum ever drops below zero, reset it to the current number (start fresh).
> - Keep track of the best sum you’ve seen so far.

I've included both solutions in my python file just in case.
**Key intuitions:**
- If having to accumulate something over an array, consider if Kadane could be applied.
### Maximum Subarray
This puts in practice "Kadane's Algorithm" in it's most traditional way. I see it as a way of dropping "dead weight" when it's not contributing anything. This is basically, if a subarray has a total sum of 0 or less, we drop it, since it won't contribute anything moving forward.
I also did a custom nice thingy where I modified it to return the indexes of the subarrays.
**Key intuition:**
- Sliding window would not work here. Why? because it's not sliding! if the sum becomes <= 0 we basically ditch the window and start over!
### Minimum Size Subarray Sum
I tried to apply Kadane at first since it's pretty similar to the previous one, but it didn't work out. It turns out that whenever we have other constraints and concerns that aren't just minimizing or maximizing a sum, then we're outta luck. From GPT-5:
> Where Kadane fits:
> - Max subarray sum (classic).
> - Max profit from one stock trade via day-to-day differences.
> - Variants that still boil down to “best contiguous sum” on a transformed array (e.g., circular arrays with tweaks, 2D via compression).
> - Min subarray sum by negating numbers and applying Kadane.

> Where it doesn’t fit directly:
> - Problems with constraints beyond sum (e.g., shortest/longest subarray meeting a threshold, at most K distinct chars, exact length k).
> - When elements can be negative and you need a constraint like “sum ≥ K” with minimal length—requires prefix sums + binary search or a deque.
> - Non-contiguous selections (that’s knapsack/DP territory).
> - Multi-criteria objectives (e.g., maximize average, ratio, or product) unless you can reduce to a sum with a transformation.
> 
> Rule of thumb:
> - If your goal is “best contiguous sum” (possibly after a simple transform), use Kadane.
> - If you’re enforcing constraints or optimizing length/indices under a threshold, reach for sliding window, prefix sums, or dynamic programming.