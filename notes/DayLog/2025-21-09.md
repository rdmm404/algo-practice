The plan for today is [[CHECKLIST#Block 2 Arrays - Subarray Sums & Kadane's Variants (Approx. 3h 55m)|Block 2]]
- **Study Questions:**
  - [x] Best Time to Buy and Sell Stock (Easy)
  - [ ] Maximum Subarray (Medium)
  - [ ] Minimum Size Subarray Sum (Medium)
- **Practice Questions:**
  - [ ] Majority Element (Easy)
  - [ ] Subarray Sum Equals K (Medium)
  - [ ] Shortest Unsorted Continuous Subarray (Medium)
  - [ ] Kth Largest Element in an Array (Medium)
## Study Questions
### Buy and Sell Stock
So i kinda thought of the two-pointer solution myself. I didn't implement it of course but I came up with it within 5 minutes. However then I discovered there was another way of solving it, applying something called "Kadane's Algorithm". This is apparently used to calculate the max subarray sum originally, but it can be tweaked to be applied here as well. The more intuitive one to me of course is the two pointers. But this one makes sense as well, here is Kadane's theory:
> [!info]-
> Kadane’s algorithm finds the largest sum of any contiguous subarray in a list in one pass.
> Simple idea:
> - Walk through the numbers, keeping a running sum of the best subarray that ends at the current position.
> - If the running sum ever drops below zero, reset it to the current number (start fresh).
> - Keep track of the best sum you’ve seen so far.

I've included both solutions in my python file just in case.
**Key intuitions:**
- If having to accumulate something over an array, consider if Kadane could be applied.