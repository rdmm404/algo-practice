
This is my first day trying this stuff out. Hopefully it'll work out. I have an interview coming up.

The plan for today is [[CHECKLIST#Block 1 Arrays - Core Two Pointers & Hashing (Approx. 3h 55m)|Block 1]]
- **Study Questions:**
  - [x] Two Sum (Easy)
  - [x] Container With Most Water (Medium)
  - [x] Merge Sorted Array (Easy)
- **Practice Questions:**
  - [x] Contains Duplicate (Easy)
  - [x] Squares of a Sorted Array (Easy)
  - [x] Move Zeroes (Easy)
  - [x] Remove Duplicates from Sorted Array (Easy)

[[01-Arrays]]Should be simple enough and take less than 3 hours as I know a lot of these concepts already.

## Study Questions
### Two Sum
Not many notes. I already knew this one like everyone does. It's very important though, involves thinking outside of the box and using hashmaps. Overall good, i'm also a bit rusty.
Time Complexity: $O(n)$, Space Complexity $O(n)$
### Max Water
I already know this one as well. I put some notes here but i closed obsidian and didn't save and i'm too lazy to write them again lol
### Merge Sorted Arrays 
So this one made me think a bit, but i think i came up with something good. At least a good way of comparing the two arrays and logic for where to put each element. But I'm still not sure how to actually put elements into the array without shifting. After watching the video: The easiest way is to start backwards, since it's already empty and we don't need to shift. I do think there is a way to do it going forward by keeping the previous value so i'll explore that as well.
**Key intuitions:**
- Consider what would happen if you traverse arrays backwards
- Always think about how having a sorted array can help
- Think of edge cases and examples
Time Complexity $O(m + n)$, Space complexity $O(1)$ 
## Practice Questions
### Contains Duplicate
Way too easy, didn't even think much about it. Just use a hash set to store the seen numbers and call it day.
Time Complexity $O(n)$, Space complexity $O(n)$ 
### Squares of a Sorted Array
Solved by myself using the most optimal approach!!!
I can see that solving Merge Sorted Arrays helped a lot. I also learned that reversing an array is $O(n)$ when I thought it was $O(n \log{n})$.
**Key Intuitions:**
- When dealing with sorted arrays, in these kinds of questions (merging into another sorted array, squares into another sorted array), two pointers seems to be the way to go.
Time Complexity $O(n)$, Space complexity $O(n)$ 
### Move Zeroes
Also solved myself using two pointers!! I can see the theme of today lol. Apparently explores similar concepts to QuickSort in terms of partitioning.
**Key intuitions:**
- Looks like, in general whenever we want to do some operation with an array in-place, two pointers is the move.
Time Complexity $O(n)$, Space complexity $O(1)$ 
### Remove duplicates from sorted array
Also solved by myself!!! Now this one was a bit harder, and i complicated myself by being too focused on having to swap elements (i guess biased by the previous question).
**Key intuitions:**
- Think if you actually need to swap elements or if it's simpler to just replace.
Time Complexity $O(n)$, Space complexity $O(1)$ 






